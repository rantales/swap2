(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3709],{10042:function(w,T,R){"use strict";var S,E,I;I=R(71618),E=R(37474),S=(function(){let Batcher=class Batcher{constructor(w={}){this.options=w,I.load(this.options,this.defaults,this),this.Events=new E(this),this._arr=[],this._resetPromise(),this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise((w,T)=>this._resolve=w)}_flush(){return clearTimeout(this._timeout),this._lastFlush=Date.now(),this._resolve(),this.Events.trigger("batch",this._arr),this._arr=[],this._resetPromise()}add(w){var T;return this._arr.push(w),T=this._promise,this._arr.length===this.maxSize?this._flush():null!=this.maxTime&&1===this._arr.length&&(this._timeout=setTimeout(()=>this._flush(),this.maxTime)),T}};return Batcher.prototype.defaults={maxTime:null,maxSize:null,Promise:Promise},Batcher}).call(void 0),w.exports=S},95474:function(w,T,R){"use strict";function _slicedToArray(w,T){return _arrayWithHoles(w)||_iterableToArrayLimit(w,T)||_nonIterableRest()}function _iterableToArrayLimit(w,T){var R=[],S=!0,E=!1,I=void 0;try{for(var O,A=w[Symbol.iterator]();!(S=(O=A.next()).done)&&(R.push(O.value),!T||R.length!==T);S=!0);}catch(w){E=!0,I=w}finally{try{S||null==A.return||A.return()}finally{if(E)throw I}}return R}function _toArray(w){return _arrayWithHoles(w)||_iterableToArray(w)||_nonIterableRest()}function _nonIterableRest(){throw TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArray(w){if(Symbol.iterator in Object(w)||"[object Arguments]"===Object.prototype.toString.call(w))return Array.from(w)}function _arrayWithHoles(w){if(Array.isArray(w))return w}function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}var S,E,I,O,A,G,C,P,q,D,B,M=[].splice;G=10,E=5,B=R(71618),C=R(30106),O=R(65030),A=R(59488),P=R(30757),I=R(37474),q=R(50355),D=R(77596),S=(function(){let Bottleneck=class Bottleneck{constructor(w={},...T){var R,S;this._addToQueue=this._addToQueue.bind(this),this._validateOptions(w,T),B.load(w,this.instanceDefaults,this),this._queues=new C(G),this._scheduled={},this._states=new q(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[])),this._limiter=null,this.Events=new I(this),this._submitLock=new D("submit",this.Promise),this._registerLock=new D("register",this.Promise),S=B.load(w,this.storeDefaults,{}),this._store=(function(){if("redis"===this.datastore||"ioredis"===this.datastore||null!=this.connection)return R=B.load(w,this.redisStoreDefaults,{}),new P(this,S,R);if("local"===this.datastore)return R=B.load(w,this.localStoreDefaults,{}),new A(this,S,R);throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}).call(this),this._queues.on("leftzero",()=>{var w;return null!=(w=this._store.heartbeat)&&"function"==typeof w.ref?w.ref():void 0}),this._queues.on("zero",()=>{var w;return null!=(w=this._store.heartbeat)&&"function"==typeof w.unref?w.unref():void 0})}_validateOptions(w,T){if(!(null!=w&&"object"==typeof w&&0===T.length))throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(w){return this._store.__publish__(w)}disconnect(w=!0){return this._store.__disconnect__(w)}chain(w){return this._limiter=w,this}queued(w){return this._queues.queued(w)}clusterQueued(){return this._store.__queued__()}empty(){return 0===this.queued()&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(w){return this._states.jobStatus(w)}jobs(w){return this._states.statusJobs(w)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(w=1){return this._store.__check__(w)}_clearGlobalState(w){return null!=this._scheduled[w]&&(clearTimeout(this._scheduled[w].expiration),delete this._scheduled[w],!0)}_free(w,T,R,S){var E=this;return _asyncToGenerator(function*(){var T,I;try{if(I=(yield E._store.__free__(w,R.weight)).running,E.Events.trigger("debug",`Freed ${R.id}`,S),0===I&&E.empty())return E.Events.trigger("idle")}catch(w){return T=w,E.Events.trigger("error",T)}})()}_run(w,T,R){var S,E,I;return T.doRun(),S=this._clearGlobalState.bind(this,w),I=this._run.bind(this,w,T),E=this._free.bind(this,w,T),this._scheduled[w]={timeout:setTimeout(()=>T.doExecute(this._limiter,S,I,E),R),expiration:null!=T.options.expiration?setTimeout(function(){return T.doExpire(S,I,E)},R+T.options.expiration):void 0,job:T}}_drainOne(w){return this._registerLock.schedule(()=>{if(0===this.queued())return this.Promise.resolve(null);var T,R,S,E,I,O=S=(I=this._queues.getFirst()).first();return(E=O.options,T=O.args,null!=w&&E.weight>w)?this.Promise.resolve(null):(this.Events.trigger("debug",`Draining ${E.id}`,{args:T,options:E}),R=this._randomIndex(),this._store.__register__(R,E.weight,E.expiration).then(({success:w,wait:O,reservoir:A})=>{var G;return(this.Events.trigger("debug",`Drained ${E.id}`,{success:w,args:T,options:E}),w)?(I.shift(),(G=this.empty())&&this.Events.trigger("empty"),0===A&&this.Events.trigger("depleted",G),this._run(R,S,O),this.Promise.resolve(E.weight)):this.Promise.resolve(null)}))})}_drainAll(w,T=0){return this._drainOne(w).then(R=>{var S;return null!=R?(S=null!=w?w-R:w,this._drainAll(S,T+R)):this.Promise.resolve(T)}).catch(w=>this.Events.trigger("error",w))}_dropAllQueued(w){return this._queues.shiftAll(function(T){return T.doDrop({message:w})})}stop(w={}){var T,R;return w=B.load(w,this.stopDefaults),R=w=>{var T;return T=()=>{var T;return(T=this._states.counts)[0]+T[1]+T[2]+T[3]===w},new this.Promise((w,R)=>T()?w():this.on("done",()=>{if(T())return this.removeAllListeners("done"),w()}))},T=w.dropWaitingJobs?(this._run=function(T,R){return R.doDrop({message:w.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule(()=>this._submitLock.schedule(()=>{var T,S,E;for(T in S=this._scheduled)E=S[T],"RUNNING"===this.jobStatus(E.job.options.id)&&(clearTimeout(E.timeout),clearTimeout(E.expiration),E.job.doDrop({message:w.dropErrorMessage}));return this._dropAllQueued(w.dropErrorMessage),R(0)}))):this.schedule({priority:G-1,weight:0},()=>R(1)),this._receive=function(T){return T._reject(new Bottleneck.prototype.BottleneckError(w.enqueueErrorMessage))},this.stop=()=>this.Promise.reject(new Bottleneck.prototype.BottleneckError("stop() has already been called")),T}_addToQueue(w){var T=this;return _asyncToGenerator(function*(){var R,S,E,I,O,A,G;R=w.args,I=w.options;try{var C=yield T._store.__submit__(T.queued(),I.weight);O=C.reachedHWM,S=C.blocked,G=C.strategy}catch(S){return E=S,T.Events.trigger("debug",`Could not queue ${I.id}`,{args:R,options:I,error:E}),w.doDrop({error:E}),!1}return S?(w.doDrop(),!0):(O&&(null!=(A=G===Bottleneck.prototype.strategy.LEAK?T._queues.shiftLastFrom(I.priority):G===Bottleneck.prototype.strategy.OVERFLOW_PRIORITY?T._queues.shiftLastFrom(I.priority+1):G===Bottleneck.prototype.strategy.OVERFLOW?w:void 0)&&A.doDrop(),null==A||G===Bottleneck.prototype.strategy.OVERFLOW)?null==A&&w.doDrop():(w.doQueue(O,S),T._queues.push(w),yield T._drainAll()),O)})()}_receive(w){return null!=this._states.jobStatus(w.options.id)?(w._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${w.options.id})`)),!1):(w.doReceive(),this._submitLock.schedule(this._addToQueue,w))}submit(...w){var T,R,S,E,I,A,G;return"function"==typeof w[0]?(R=(A=_toArray(w))[0],w=A.slice(1),T=_slicedToArray(M.call(w,-1),1)[0],E=B.load({},this.jobDefaults)):(E=(G=_toArray(w))[0],R=G[1],w=G.slice(2),T=_slicedToArray(M.call(w,-1),1)[0],E=B.load(E,this.jobDefaults)),I=(...w)=>new this.Promise(function(T,S){return R(...w,function(...w){return(null!=w[0]?S:T)(w)})}),(S=new O(I,w,E,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise)).promise.then(function(w){return"function"==typeof T?T(...w):void 0}).catch(function(w){return Array.isArray(w)?"function"==typeof T?T(...w):void 0:"function"==typeof T?T(w):void 0}),this._receive(S)}schedule(...w){var T,R,S;if("function"==typeof w[0]){var E=_toArray(w);S=E[0],w=E.slice(1),R={}}else{var I=_toArray(w);R=I[0],S=I[1],w=I.slice(2)}return T=new O(S,w,R,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),this._receive(T),T.promise}wrap(w){var T,R;return T=this.schedule.bind(this),(R=function(...R){return T(w.bind(this),...R)}).withOptions=function(R,...S){return T(R,w,...S)},R}updateSettings(w={}){var T=this;return _asyncToGenerator(function*(){return yield T._store.__updateSettings__(B.overwrite(w,T.storeDefaults)),B.overwrite(w,T.instanceDefaults,T),T})()}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(w=0){return this._store.__incrementReservoir__(w)}};return Bottleneck.default=Bottleneck,Bottleneck.Events=I,Bottleneck.version=Bottleneck.prototype.version=R(31447).i,Bottleneck.strategy=Bottleneck.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3},Bottleneck.BottleneckError=Bottleneck.prototype.BottleneckError=R(68988),Bottleneck.Group=Bottleneck.prototype.Group=R(97245),Bottleneck.RedisConnection=Bottleneck.prototype.RedisConnection=R(77556),Bottleneck.IORedisConnection=Bottleneck.prototype.IORedisConnection=R(21885),Bottleneck.Batcher=Bottleneck.prototype.Batcher=R(10042),Bottleneck.prototype.jobDefaults={priority:E,weight:1,expiration:null,id:"<no-id>"},Bottleneck.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:Bottleneck.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null},Bottleneck.prototype.localStoreDefaults={Promise:Promise,timeout:null,heartbeatInterval:250},Bottleneck.prototype.redisStoreDefaults={Promise:Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,Redis:null,clientOptions:{},clusterNodes:null,clearDatastore:!1,connection:null},Bottleneck.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:!0,trackDoneStatus:!1,Promise:Promise},Bottleneck.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:!0,dropErrorMessage:"This limiter has been stopped."},Bottleneck}).call(void 0),w.exports=S},68988:function(w){"use strict";var T;T=class extends Error{},w.exports=T},41949:function(w){"use strict";var T;T=class{constructor(w,T){this.incr=w,this.decr=T,this._first=null,this._last=null,this.length=0}push(w){var T;this.length++,"function"==typeof this.incr&&this.incr(),T={value:w,prev:this._last,next:null},null!=this._last?(this._last.next=T,this._last=T):this._first=this._last=T}shift(){var w;return null==this._first?void 0:(this.length--,"function"==typeof this.decr&&this.decr(),w=this._first.value,null!=(this._first=this._first.next)?this._first.prev=null:this._last=null,w)}first(){if(null!=this._first)return this._first.value}getArray(){var w,T,R;for(w=this._first,R=[];null!=w;)R.push((T=w,w=w.next,T.value));return R}forEachShift(w){var T;for(T=this.shift();null!=T;)w(T),T=this.shift()}debug(){var w,T,R,S,E;for(w=this._first,E=[];null!=w;)E.push((T=w,w=w.next,{value:T.value,prev:null!=(R=T.prev)?R.value:void 0,next:null!=(S=T.next)?S.value:void 0}));return E}},w.exports=T},37474:function(w){"use strict";var T;function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}T=class{constructor(w){if(this.instance=w,this._events={},null!=this.instance.on||null!=this.instance.once||null!=this.instance.removeAllListeners)throw Error("An Emitter already exists for this object");this.instance.on=(w,T)=>this._addListener(w,"many",T),this.instance.once=(w,T)=>this._addListener(w,"once",T),this.instance.removeAllListeners=(w=null)=>null!=w?delete this._events[w]:this._events={}}_addListener(w,T,R){var S;return null==(S=this._events)[w]&&(S[w]=[]),this._events[w].push({cb:R,status:T}),this.instance}listenerCount(w){return null!=this._events[w]?this._events[w].length:0}trigger(w,...T){var R=this;return _asyncToGenerator(function*(){var S,E;try{if("debug"!==w&&R.trigger("debug",`Event triggered: ${w}`,T),null==R._events[w])return;return R._events[w]=R._events[w].filter(function(w){return"none"!==w.status}),E=R._events[w].map(function(){var w=_asyncToGenerator(function*(w){var S,E;if("none"!==w.status){"once"===w.status&&(w.status="none");try{if(E="function"==typeof w.cb?w.cb(...T):void 0,"function"==typeof(null!=E?E.then:void 0))return yield E;return E}catch(w){return S=w,R.trigger("error",S),null}}});return function(T){return w.apply(this,arguments)}}()),(yield Promise.all(E)).find(function(w){return null!=w})}catch(w){return S=w,R.trigger("error",S),null}})()}},w.exports=T},97245:function(w,T,R){"use strict";var S,E,I,O,A,G;function _slicedToArray(w,T){return _arrayWithHoles(w)||_iterableToArrayLimit(w,T)||_nonIterableRest()}function _nonIterableRest(){throw TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(w,T){var R=[],S=!0,E=!1,I=void 0;try{for(var O,A=w[Symbol.iterator]();!(S=(O=A.next()).done)&&(R.push(O.value),!T||R.length!==T);S=!0);}catch(w){E=!0,I=w}finally{try{S||null==A.return||A.return()}finally{if(E)throw I}}return R}function _arrayWithHoles(w){if(Array.isArray(w))return w}function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}G=R(71618),S=R(37474),O=R(77556),I=R(21885),A=R(29336),E=(function(){let Group=class Group{constructor(w={}){this.deleteKey=this.deleteKey.bind(this),this.limiterOptions=w,G.load(this.limiterOptions,this.defaults,this),this.Events=new S(this),this.instances={},this.Bottleneck=R(95474),this._startAutoCleanup(),this.sharedConnection=null!=this.connection,null==this.connection&&("redis"===this.limiterOptions.datastore?this.connection=new O(Object.assign({},this.limiterOptions,{Events:this.Events})):"ioredis"===this.limiterOptions.datastore&&(this.connection=new I(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(w=""){var T;return null!=(T=this.instances[w])?T:(()=>{var T;return T=this.instances[w]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${w}`,timeout:this.timeout,connection:this.connection})),this.Events.trigger("created",T,w),T})()}deleteKey(w=""){var T=this;return _asyncToGenerator(function*(){var R,S;return S=T.instances[w],T.connection&&(R=yield T.connection.__runCommand__(["del",...A.allKeys(`${T.id}-${w}`)])),null!=S&&(delete T.instances[w],yield S.disconnect()),null!=S||R>0})()}limiters(){var w,T,R,S;for(w in T=this.instances,R=[],T)S=T[w],R.push({key:w,limiter:S});return R}keys(){return Object.keys(this.instances)}clusterKeys(){var w=this;return _asyncToGenerator(function*(){var T,R,S,E,I,O,A,G,C;if(null==w.connection)return w.Promise.resolve(w.keys());for(O=[],T=null,C=`b_${w.id}-`.length,R=9;0!==T;){var P=_slicedToArray((yield w.connection.__runCommand__(["scan",null!=T?T:0,"match",`b_${w.id}-*_settings`,"count",1e4])),2);for(E=0,G=P[0],S=P[1],T=~~G,A=S.length;E<A;E++)I=S[E],O.push(I.slice(C,-R))}return O})()}_startAutoCleanup(){var w,T=this;return clearInterval(this.interval),"function"==typeof(w=this.interval=setInterval(_asyncToGenerator(function*(){var w,R,S,E,I,O;for(R in I=Date.now(),S=T.instances,E=[],S){O=S[R];try{(yield O._store.__groupCheck__(I))?E.push(T.deleteKey(R)):E.push(void 0)}catch(T){w=T,E.push(O.Events.trigger("error",w))}}return E}),this.timeout/2)).unref?w.unref():void 0}updateSettings(w={}){if(G.overwrite(w,this.defaults,this),G.overwrite(w,w,this.limiterOptions),null!=w.timeout)return this._startAutoCleanup()}disconnect(w=!0){var T;if(!this.sharedConnection)return null!=(T=this.connection)?T.disconnect(w):void 0}};return Group.prototype.defaults={timeout:3e5,connection:null,Promise:Promise,id:"group-key"},Group}).call(void 0),w.exports=E},21885:function(module,__unused_webpack_exports,__webpack_require__){"use strict";var Events,IORedisConnection,Scripts,parser;function _slicedToArray(w,T){return _arrayWithHoles(w)||_iterableToArrayLimit(w,T)||_nonIterableRest()}function _nonIterableRest(){throw TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(w,T){var R=[],S=!0,E=!1,I=void 0;try{for(var O,A=w[Symbol.iterator]();!(S=(O=A.next()).done)&&(R.push(O.value),!T||R.length!==T);S=!0);}catch(w){E=!0,I=w}finally{try{S||null==A.return||A.return()}finally{if(E)throw I}}return R}function _arrayWithHoles(w){if(Array.isArray(w))return w}function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}parser=__webpack_require__(71618),Events=__webpack_require__(37474),Scripts=__webpack_require__(29336),IORedisConnection=(function(){let IORedisConnection=class IORedisConnection{constructor(options={}){parser.load(options,this.defaults,this),null==this.Redis&&(this.Redis=eval("require")("ioredis")),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null!=this.clusterNodes?(this.client=new this.Redis.Cluster(this.clusterNodes,this.clientOptions),this.subscriber=new this.Redis.Cluster(this.clusterNodes,this.clientOptions)):null!=this.client&&null==this.client.duplicate?this.subscriber=new this.Redis.Cluster(this.client.startupNodes,this.client.options):(null==this.client&&(this.client=new this.Redis(this.clientOptions)),this.subscriber=this.client.duplicate()),this.limiters={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then(()=>(this._loadScripts(),{client:this.client,subscriber:this.subscriber}))}_setup(w,T){return w.setMaxListeners(0),new this.Promise((R,S)=>(w.on("error",w=>this.Events.trigger("error",w)),T&&w.on("message",(w,T)=>{var R;return null!=(R=this.limiters[w])?R._store.onMessage(w,T):void 0}),"ready"===w.status)?R():w.once("ready",R))}_loadScripts(){return Scripts.names.forEach(w=>this.client.defineCommand(w,{lua:Scripts.payload(w)}))}__runCommand__(w){var T=this;return _asyncToGenerator(function*(){yield T.ready;var R,S=_slicedToArray((yield T.client.pipeline([w]).exec()),1),E=_slicedToArray(S[0],2);return R=E[0],E[1]})()}__addLimiter__(w){return this.Promise.all([w.channel(),w.channel_client()].map(T=>new this.Promise((R,S)=>this.subscriber.subscribe(T,()=>(this.limiters[T]=w,R())))))}__removeLimiter__(w){var T=this;return[w.channel(),w.channel_client()].forEach(function(){var w=_asyncToGenerator(function*(w){return T.terminated||(yield T.subscriber.unsubscribe(w)),delete T.limiters[w]});return function(T){return w.apply(this,arguments)}}())}__scriptArgs__(w,T,R,S){var E;return[(E=Scripts.keys(w,T)).length].concat(E,R,S)}__scriptFn__(w){return this.client[w].bind(this.client)}disconnect(w=!0){var T,R,S,E;for(T=0,S=(E=Object.keys(this.limiters)).length;T<S;T++)R=E[T],clearInterval(this.limiters[R]._store.heartbeat);return(this.limiters={},this.terminated=!0,w)?this.Promise.all([this.client.quit(),this.subscriber.quit()]):(this.client.disconnect(),this.subscriber.disconnect(),this.Promise.resolve())}};return IORedisConnection.prototype.datastore="ioredis",IORedisConnection.prototype.defaults={Redis:null,clientOptions:{},clusterNodes:null,client:null,Promise:Promise,Events:null},IORedisConnection}).call(void 0),module.exports=IORedisConnection},65030:function(w,T,R){"use strict";var S,E,I,O,A;function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}O=10,E=5,A=R(71618),S=R(68988),I=class{constructor(w,T,R,S,E,I,O,G){this.task=w,this.args=T,this.rejectOnDrop=E,this.Events=I,this._states=O,this.Promise=G,this.options=A.load(R,S),this.options.priority=this._sanitizePriority(this.options.priority),this.options.id===S.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`),this.promise=new this.Promise((w,T)=>{this._resolve=w,this._reject=T}),this.retryCount=0}_sanitizePriority(w){var T;return(T=~~w!==w?E:w)<0?0:T>O-1?O-1:T}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error:w,message:T="This job has been dropped by Bottleneck"}={}){return!!this._states.remove(this.options.id)&&(this.rejectOnDrop&&this._reject(null!=w?w:new S(T)),this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise}),!0)}_assertStatus(w){var T;if(!((T=this._states.jobStatus(this.options.id))===w||"DONE"===w&&null===T))throw new S(`Invalid job status ${T}, expected ${w}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){return this._states.start(this.options.id),this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(w,T){return this._assertStatus("RECEIVED"),this._states.next(this.options.id),this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM:w,blocked:T})}doRun(){return 0===this.retryCount?(this._assertStatus("QUEUED"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),this.Events.trigger("scheduled",{args:this.args,options:this.options})}doExecute(w,T,R,S){var E=this;return _asyncToGenerator(function*(){var I,O,A;0===E.retryCount?(E._assertStatus("RUNNING"),E._states.next(E.options.id)):E._assertStatus("EXECUTING"),O={args:E.args,options:E.options,retryCount:E.retryCount},E.Events.trigger("executing",O);try{if(A=yield null!=w?w.schedule(E.options,E.task,...E.args):E.task(...E.args),T())return E.doDone(O),yield S(E.options,O),E._assertStatus("DONE"),E._resolve(A)}catch(w){return I=w,E._onFailure(I,O,T,R,S)}})()}doExpire(w,T,R){var E,I;return this._states.jobStatus("RUNNING"===this.options.id)&&this._states.next(this.options.id),this._assertStatus("EXECUTING"),I={args:this.args,options:this.options,retryCount:this.retryCount},E=new S(`This job timed out after ${this.options.expiration} ms.`),this._onFailure(E,I,w,T,R)}_onFailure(w,T,R,S,E){var I=this;return _asyncToGenerator(function*(){var O,A;if(R())return null!=(O=yield I.Events.trigger("failed",w,T))?(A=~~O,I.Events.trigger("retry",`Retrying ${I.options.id} after ${A} ms`,T),I.retryCount++,S(A)):(I.doDone(T),yield E(I.options,T),I._assertStatus("DONE"),I._reject(w))})()}doDone(w){return this._assertStatus("EXECUTING"),this._states.next(this.options.id),this.Events.trigger("done",w)}},w.exports=I},59488:function(w,T,R){"use strict";var S,E,I;function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}I=R(71618),S=R(68988),E=class{constructor(w,T,R){this.instance=w,this.storeOptions=T,this.clientId=this.instance._randomIndex(),I.load(R,R,this),this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now(),this._running=0,this._done=0,this._unblockTime=0,this.ready=this.Promise.resolve(),this.clients={},this._startHeartbeat()}_startHeartbeat(){var w;return null==this.heartbeat&&(null!=this.storeOptions.reservoirRefreshInterval&&null!=this.storeOptions.reservoirRefreshAmount||null!=this.storeOptions.reservoirIncreaseInterval&&null!=this.storeOptions.reservoirIncreaseAmount)?"function"==typeof(w=this.heartbeat=setInterval(()=>{var w,T,R,S,E;if(S=Date.now(),null!=this.storeOptions.reservoirRefreshInterval&&S>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval&&(this._lastReservoirRefresh=S,this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount,this.instance._drainAll(this.computeCapacity())),null!=this.storeOptions.reservoirIncreaseInterval&&S>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval){var I=this.storeOptions;if(w=I.reservoirIncreaseAmount,R=I.reservoirIncreaseMaximum,E=I.reservoir,this._lastReservoirIncrease=S,(T=null!=R?Math.min(w,R-E):w)>0)return this.storeOptions.reservoir+=T,this.instance._drainAll(this.computeCapacity())}},this.heartbeatInterval)).unref?w.unref():void 0:clearInterval(this.heartbeat)}__publish__(w){var T=this;return _asyncToGenerator(function*(){return yield T.yieldLoop(),T.instance.Events.trigger("message",w.toString())})()}__disconnect__(w){var T=this;return _asyncToGenerator(function*(){return yield T.yieldLoop(),clearInterval(T.heartbeat),T.Promise.resolve()})()}yieldLoop(w=0){return new this.Promise(function(T,R){return setTimeout(T,w)})}computePenalty(){var w;return null!=(w=this.storeOptions.penalty)?w:15*this.storeOptions.minTime||5e3}__updateSettings__(w){var T=this;return _asyncToGenerator(function*(){return yield T.yieldLoop(),I.overwrite(w,w,T.storeOptions),T._startHeartbeat(),T.instance._drainAll(T.computeCapacity()),!0})()}__running__(){var w=this;return _asyncToGenerator(function*(){return yield w.yieldLoop(),w._running})()}__queued__(){var w=this;return _asyncToGenerator(function*(){return yield w.yieldLoop(),w.instance.queued()})()}__done__(){var w=this;return _asyncToGenerator(function*(){return yield w.yieldLoop(),w._done})()}__groupCheck__(w){var T=this;return _asyncToGenerator(function*(){return yield T.yieldLoop(),T._nextRequest+T.timeout<w})()}computeCapacity(){var w,T,R=this.storeOptions;return(w=R.maxConcurrent,T=R.reservoir,null!=w&&null!=T)?Math.min(w-this._running,T):null!=w?w-this._running:null!=T?T:null}conditionsCheck(w){var T;return null==(T=this.computeCapacity())||w<=T}__incrementReservoir__(w){var T=this;return _asyncToGenerator(function*(){var R;return yield T.yieldLoop(),R=T.storeOptions.reservoir+=w,T.instance._drainAll(T.computeCapacity()),R})()}__currentReservoir__(){var w=this;return _asyncToGenerator(function*(){return yield w.yieldLoop(),w.storeOptions.reservoir})()}isBlocked(w){return this._unblockTime>=w}check(w,T){return this.conditionsCheck(w)&&this._nextRequest-T<=0}__check__(w){var T=this;return _asyncToGenerator(function*(){var R;return yield T.yieldLoop(),R=Date.now(),T.check(w,R)})()}__register__(w,T,R){var S=this;return _asyncToGenerator(function*(){var w,R;return(yield S.yieldLoop(),w=Date.now(),S.conditionsCheck(T))?(S._running+=T,null!=S.storeOptions.reservoir&&(S.storeOptions.reservoir-=T),R=Math.max(S._nextRequest-w,0),S._nextRequest=w+R+S.storeOptions.minTime,{success:!0,wait:R,reservoir:S.storeOptions.reservoir}):{success:!1}})()}strategyIsBlock(){return 3===this.storeOptions.strategy}__submit__(w,T){var R=this;return _asyncToGenerator(function*(){var E,I,O;if(yield R.yieldLoop(),null!=R.storeOptions.maxConcurrent&&T>R.storeOptions.maxConcurrent)throw new S(`Impossible to add a job having a weight of ${T} to a limiter having a maxConcurrent setting of ${R.storeOptions.maxConcurrent}`);return I=Date.now(),O=null!=R.storeOptions.highWater&&w===R.storeOptions.highWater&&!R.check(T,I),(E=R.strategyIsBlock()&&(O||R.isBlocked(I)))&&(R._unblockTime=I+R.computePenalty(),R._nextRequest=R._unblockTime+R.storeOptions.minTime,R.instance._dropAllQueued()),{reachedHWM:O,blocked:E,strategy:R.storeOptions.strategy}})()}__free__(w,T){var R=this;return _asyncToGenerator(function*(){return yield R.yieldLoop(),R._running-=T,R._done+=T,R.instance._drainAll(R.computeCapacity()),{running:R._running}})()}},w.exports=E},30106:function(w,T,R){"use strict";var S,E,I;S=R(41949),E=R(37474),I=class{constructor(w){var T;this.Events=new E(this),this._length=0,this._lists=(function(){var R,E,I;for(I=[],T=R=1,E=w;1<=E?R<=E:R>=E;T=1<=E?++R:--R)I.push(new S(()=>this.incr(),()=>this.decr()));return I}).call(this)}incr(){if(0==this._length++)return this.Events.trigger("leftzero")}decr(){if(0==--this._length)return this.Events.trigger("zero")}push(w){return this._lists[w.options.priority].push(w)}queued(w){return null!=w?this._lists[w].length:this._length}shiftAll(w){return this._lists.forEach(function(T){return T.forEachShift(w)})}getFirst(w=this._lists){var T,R,S;for(T=0,R=w.length;T<R;T++)if((S=w[T]).length>0)return S;return[]}shiftLastFrom(w){return this.getFirst(this._lists.slice(w).reverse()).shift()}},w.exports=I},77556:function(module,__unused_webpack_exports,__webpack_require__){"use strict";var Events,RedisConnection,Scripts,parser;function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}parser=__webpack_require__(71618),Events=__webpack_require__(37474),Scripts=__webpack_require__(29336),RedisConnection=(function(){let RedisConnection=class RedisConnection{constructor(options={}){parser.load(options,this.defaults,this),null==this.Redis&&(this.Redis=eval("require")("redis")),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null==this.client&&(this.client=this.Redis.createClient(this.clientOptions)),this.subscriber=this.client.duplicate(),this.limiters={},this.shas={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then(()=>this._loadScripts()).then(()=>({client:this.client,subscriber:this.subscriber}))}_setup(w,T){return w.setMaxListeners(0),new this.Promise((R,S)=>(w.on("error",w=>this.Events.trigger("error",w)),T&&w.on("message",(w,T)=>{var R;return null!=(R=this.limiters[w])?R._store.onMessage(w,T):void 0}),w.ready)?R():w.once("ready",R))}_loadScript(w){return new this.Promise((T,R)=>{var S;return S=Scripts.payload(w),this.client.multi([["script","load",S]]).exec((S,E)=>null!=S?R(S):(this.shas[w]=E[0],T(E[0])))})}_loadScripts(){return this.Promise.all(Scripts.names.map(w=>this._loadScript(w)))}__runCommand__(w){var T=this;return _asyncToGenerator(function*(){return yield T.ready,new T.Promise((R,S)=>T.client.multi([w]).exec_atomic(function(w,T){return null!=w?S(w):R(T[0])}))})()}__addLimiter__(w){return this.Promise.all([w.channel(),w.channel_client()].map(T=>new this.Promise((R,S)=>{var E;return E=S=>{if(S===T)return this.subscriber.removeListener("subscribe",E),this.limiters[T]=w,R()},this.subscriber.on("subscribe",E),this.subscriber.subscribe(T)})))}__removeLimiter__(w){var T=this;return this.Promise.all([w.channel(),w.channel_client()].map(function(){var w=_asyncToGenerator(function*(w){return T.terminated||(yield new T.Promise((R,S)=>T.subscriber.unsubscribe(w,function(T,E){return null!=T?S(T):E===w?R():void 0}))),delete T.limiters[w]});return function(T){return w.apply(this,arguments)}}()))}__scriptArgs__(w,T,R,S){var E;return E=Scripts.keys(w,T),[this.shas[w],E.length].concat(E,R,S)}__scriptFn__(w){return this.client.evalsha.bind(this.client)}disconnect(w=!0){var T,R,S,E;for(T=0,S=(E=Object.keys(this.limiters)).length;T<S;T++)R=E[T],clearInterval(this.limiters[R]._store.heartbeat);return this.limiters={},this.terminated=!0,this.client.end(w),this.subscriber.end(w),this.Promise.resolve()}};return RedisConnection.prototype.datastore="redis",RedisConnection.prototype.defaults={Redis:null,clientOptions:{},client:null,Promise:Promise,Events:null},RedisConnection}).call(void 0),module.exports=RedisConnection},30757:function(w,T,R){"use strict";var S,E,I,O,A;function _slicedToArray(w,T){return _arrayWithHoles(w)||_iterableToArrayLimit(w,T)||_nonIterableRest()}function _nonIterableRest(){throw TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(w,T){var R=[],S=!0,E=!1,I=void 0;try{for(var O,A=w[Symbol.iterator]();!(S=(O=A.next()).done)&&(R.push(O.value),!T||R.length!==T);S=!0);}catch(w){E=!0,I=w}finally{try{S||null==A.return||A.return()}finally{if(E)throw I}}return R}function _arrayWithHoles(w){if(Array.isArray(w))return w}function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}A=R(71618),S=R(68988),I=R(77556),E=R(21885),O=class{constructor(w,T,R){this.instance=w,this.storeOptions=T,this.originalId=this.instance.id,this.clientId=this.instance._randomIndex(),A.load(R,R,this),this.clients={},this.capacityPriorityCounters={},this.sharedConnection=null!=this.connection,null==this.connection&&(this.connection="redis"===this.instance.datastore?new I({Redis:this.Redis,clientOptions:this.clientOptions,Promise:this.Promise,Events:this.instance.Events}):"ioredis"===this.instance.datastore?new E({Redis:this.Redis,clientOptions:this.clientOptions,clusterNodes:this.clusterNodes,Promise:this.Promise,Events:this.instance.Events}):void 0),this.instance.connection=this.connection,this.instance.datastore=this.connection.datastore,this.ready=this.connection.ready.then(w=>(this.clients=w,this.runScript("init",this.prepareInitSettings(this.clearDatastore)))).then(()=>this.connection.__addLimiter__(this.instance)).then(()=>this.runScript("register_client",[this.instance.queued()])).then(()=>{var w;return"function"==typeof(w=this.heartbeat=setInterval(()=>this.runScript("heartbeat",[]).catch(w=>this.instance.Events.trigger("error",w)),this.heartbeatInterval)).unref&&w.unref(),this.clients})}__publish__(w){var T=this;return _asyncToGenerator(function*(){return(yield T.ready).client.publish(T.instance.channel(),`message:${w.toString()}`)})()}onMessage(w,T){var R=this;return _asyncToGenerator(function*(){var w,S,E,I,O,A,G,C,P,q;try{G=T.indexOf(":");var D=[T.slice(0,G),T.slice(G+1)];if(q=D[0],E=D[1],"capacity"===q)return yield R.instance._drainAll(E.length>0?~~E:void 0);if("capacity-priority"===q){var B=E.split(":"),M=_slicedToArray(B,3);if(P=M[0],C=M[1],S=M[2],w=P.length>0?~~P:void 0,C===R.clientId)return I=yield R.instance._drainAll(w),A=null!=w?w-(I||0):"",yield R.clients.client.publish(R.instance.channel(),`capacity-priority:${A}::${S}`);if(""===C)return clearTimeout(R.capacityPriorityCounters[S]),delete R.capacityPriorityCounters[S],R.instance._drainAll(w);return R.capacityPriorityCounters[S]=setTimeout(_asyncToGenerator(function*(){var T;try{return delete R.capacityPriorityCounters[S],yield R.runScript("blacklist_client",[C]),yield R.instance._drainAll(w)}catch(w){return T=w,R.instance.Events.trigger("error",T)}}),1e3)}if("message"===q)return R.instance.Events.trigger("message",E);if("blocked"===q)return yield R.instance._dropAllQueued()}catch(w){return O=w,R.instance.Events.trigger("error",O)}})()}__disconnect__(w){return(clearInterval(this.heartbeat),this.sharedConnection)?this.connection.__removeLimiter__(this.instance):this.connection.disconnect(w)}runScript(w,T){var R=this;return _asyncToGenerator(function*(){return"init"===w||"register_client"===w||(yield R.ready),new R.Promise((S,E)=>{var I,O;return I=[Date.now(),R.clientId].concat(T),R.instance.Events.trigger("debug",`Calling Redis script: ${w}.lua`,I),O=R.connection.__scriptArgs__(w,R.originalId,I,function(w,T){return null!=w?E(w):S(T)}),R.connection.__scriptFn__(w)(...O)}).catch(S=>"SETTINGS_KEY_NOT_FOUND"===S.message?"heartbeat"===w?R.Promise.resolve():R.runScript("init",R.prepareInitSettings(!1)).then(()=>R.runScript(w,T)):"UNKNOWN_CLIENT"===S.message?R.runScript("register_client",[R.instance.queued()]).then(()=>R.runScript(w,T)):R.Promise.reject(S))})()}prepareArray(w){var T,R,S,E;for(T=0,S=[],R=w.length;T<R;T++)E=w[T],S.push(null!=E?E.toString():"");return S}prepareObject(w){var T,R,S;for(R in T=[],w)S=w[R],T.push(R,null!=S?S.toString():"");return T}prepareInitSettings(w){var T;return(T=this.prepareObject(Object.assign({},this.storeOptions,{id:this.originalId,version:this.instance.version,groupTimeout:this.timeout,clientTimeout:this.clientTimeout}))).unshift(w?1:0,this.instance.version),T}convertBool(w){return!!w}__updateSettings__(w){var T=this;return _asyncToGenerator(function*(){return yield T.runScript("update_settings",T.prepareObject(w)),A.overwrite(w,w,T.storeOptions)})()}__running__(){return this.runScript("running",[])}__queued__(){return this.runScript("queued",[])}__done__(){return this.runScript("done",[])}__groupCheck__(){var w=this;return _asyncToGenerator(function*(){return w.convertBool((yield w.runScript("group_check",[])))})()}__incrementReservoir__(w){return this.runScript("increment_reservoir",[w])}__currentReservoir__(){return this.runScript("current_reservoir",[])}__check__(w){var T=this;return _asyncToGenerator(function*(){return T.convertBool((yield T.runScript("check",T.prepareArray([w]))))})()}__register__(w,T,R){var S=this;return _asyncToGenerator(function*(){var E,I,O,A=_slicedToArray((yield S.runScript("register",S.prepareArray([w,T,R]))),3);return I=A[0],O=A[1],E=A[2],{success:S.convertBool(I),wait:O,reservoir:E}})()}__submit__(w,T){var R=this;return _asyncToGenerator(function*(){var E,I,O,A,G,C;try{var P=yield R.runScript("submit",R.prepareArray([w,T])),q=_slicedToArray(P,3);return G=q[0],E=q[1],C=q[2],{reachedHWM:R.convertBool(G),blocked:R.convertBool(E),strategy:C}}catch(w){if(0===(I=w).message.indexOf("OVERWEIGHT")){var D=_slicedToArray(I.message.split(":"),3);throw A=D[0],T=D[1],O=D[2],new S(`Impossible to add a job having a weight of ${T} to a limiter having a maxConcurrent setting of ${O}`)}throw I}})()}__free__(w,T){var R=this;return _asyncToGenerator(function*(){return{running:yield R.runScript("free",R.prepareArray([w]))}})()}},w.exports=O},29336:function(w,T,R){"use strict";var S,E,I;S={refs:(E=R(93068))["refs.lua"],validate_keys:E["validate_keys.lua"],validate_client:E["validate_client.lua"],refresh_expiration:E["refresh_expiration.lua"],process_tick:E["process_tick.lua"],conditions_check:E["conditions_check.lua"],get_time:E["get_time.lua"]},T.allKeys=function(w){return[`b_${w}_settings`,`b_${w}_job_weights`,`b_${w}_job_expirations`,`b_${w}_job_clients`,`b_${w}_client_running`,`b_${w}_client_num_queued`,`b_${w}_client_last_registered`,`b_${w}_client_last_seen`]},I={init:{keys:T.allKeys,headers:["process_tick"],refresh_expiration:!0,code:E["init.lua"]},group_check:{keys:T.allKeys,headers:[],refresh_expiration:!1,code:E["group_check.lua"]},register_client:{keys:T.allKeys,headers:["validate_keys"],refresh_expiration:!1,code:E["register_client.lua"]},blacklist_client:{keys:T.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:E["blacklist_client.lua"]},heartbeat:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:E["heartbeat.lua"]},update_settings:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:E["update_settings.lua"]},running:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:E["running.lua"]},queued:{keys:T.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:E["queued.lua"]},done:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:E["done.lua"]},check:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!1,code:E["check.lua"]},submit:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:E["submit.lua"]},register:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:E["register.lua"]},free:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:E["free.lua"]},current_reservoir:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:E["current_reservoir.lua"]},increment_reservoir:{keys:T.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:E["increment_reservoir.lua"]}},T.names=Object.keys(I),T.keys=function(w,T){return I[w].keys(T)},T.payload=function(w){var T;return T=I[w],Array.prototype.concat(S.refs,T.headers.map(function(w){return S[w]}),T.refresh_expiration?S.refresh_expiration:"",T.code).join("\n")}},50355:function(w,T,R){"use strict";var S,E;S=R(68988),E=class{constructor(w){this.status=w,this._jobs={},this.counts=this.status.map(function(){return 0})}next(w){var T,R;return(R=(T=this._jobs[w])+1,null!=T&&R<this.status.length)?(this.counts[T]--,this.counts[R]++,this._jobs[w]++):null!=T?(this.counts[T]--,delete this._jobs[w]):void 0}start(w){var T;return T=0,this._jobs[w]=T,this.counts[T]++}remove(w){var T;return null!=(T=this._jobs[w])&&(this.counts[T]--,delete this._jobs[w]),null!=T}jobStatus(w){var T;return null!=(T=this.status[this._jobs[w]])?T:null}statusJobs(w){var T,R,E,I;if(null==w)return Object.keys(this._jobs);if((R=this.status.indexOf(w))<0)throw new S(`status must be one of ${this.status.join(", ")}`);for(T in E=this._jobs,I=[],E)E[T]===R&&I.push(T);return I}statusCounts(){return this.counts.reduce((w,T,R)=>(w[this.status[R]]=T,w),{})}},w.exports=E},77596:function(w,T,R){"use strict";var S,E;function asyncGeneratorStep(w,T,R,S,E,I,O){try{var A=w[I](O),G=A.value}catch(w){R(w);return}A.done?T(G):Promise.resolve(G).then(S,E)}function _asyncToGenerator(w){return function(){var T=this,R=arguments;return new Promise(function(S,E){var I=w.apply(T,R);function _next(w){asyncGeneratorStep(I,S,E,_next,_throw,"next",w)}function _throw(w){asyncGeneratorStep(I,S,E,_next,_throw,"throw",w)}_next(void 0)})}}S=R(41949),E=class{constructor(w,T){this.schedule=this.schedule.bind(this),this.name=w,this.Promise=T,this._running=0,this._queue=new S}isEmpty(){return 0===this._queue.length}_tryToRun(){var w=this;return _asyncToGenerator(function*(){var T,R,S,E,I,O,A;if(w._running<1&&w._queue.length>0){w._running++;var G=w._queue.shift();return A=G.task,T=G.args,I=G.resolve,E=G.reject,R=yield _asyncToGenerator(function*(){try{return O=yield A(...T),function(){return I(O)}}catch(w){return S=w,function(){return E(S)}}})(),w._running--,w._tryToRun(),R()}})()}schedule(w,...T){var R,S,E;return E=S=null,R=new this.Promise(function(w,T){return E=w,S=T}),this._queue.push({task:w,args:T,resolve:E,reject:S}),this._tryToRun(),R}},w.exports=E},43960:function(w,T,R){"use strict";w.exports=R(95474)},71618:function(w,T){"use strict";T.load=function(w,T,R={}){var S,E,I;for(S in T)I=T[S],R[S]=null!=(E=w[S])?E:I;return R},T.overwrite=function(w,T,R={}){var S,E;for(S in w)E=w[S],void 0!==T[S]&&(R[S]=E);return R}},95385:function(w){!function(T,R){w.exports=R()}(0,function(){"use strict";var w,T,R=1e3,S=6e4,E=36e5,I=864e5,O=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,A=31536e6,G=2628e6,C=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,P={years:31536e6,months:2628e6,days:864e5,hours:36e5,minutes:6e4,seconds:1e3,milliseconds:1,weeks:6048e5},c=function(w){return w instanceof q},f=function(w,T,R){return new q(w,R,T.$l)},m=function(w){return T.p(w)+"s"},l=function(w){return w<0},$=function(w){return l(w)?Math.ceil(w):Math.floor(w)},y=function(w){return Math.abs(w)},v=function(w,T){return w?l(w)?{negative:!0,format:""+y(w)+T}:{negative:!1,format:""+w+T}:{negative:!1,format:""}},q=function(){function l(w,T,R){var S=this;if(this.$d={},this.$l=R,void 0===w&&(this.$ms=0,this.parseFromMilliseconds()),T)return f(w*P[m(T)],this);if("number"==typeof w)return this.$ms=w,this.parseFromMilliseconds(),this;if("object"==typeof w)return Object.keys(w).forEach(function(T){S.$d[m(T)]=w[T]}),this.calMilliseconds(),this;if("string"==typeof w){var E=w.match(C);if(E){var I=E.slice(2).map(function(w){return null!=w?Number(w):0});return this.$d.years=I[0],this.$d.months=I[1],this.$d.weeks=I[2],this.$d.days=I[3],this.$d.hours=I[4],this.$d.minutes=I[5],this.$d.seconds=I[6],this.calMilliseconds(),this}}return this}var q=l.prototype;return q.calMilliseconds=function(){var w=this;this.$ms=Object.keys(this.$d).reduce(function(T,R){return T+(w.$d[R]||0)*P[R]},0)},q.parseFromMilliseconds=function(){var w=this.$ms;this.$d.years=$(w/A),w%=A,this.$d.months=$(w/G),w%=G,this.$d.days=$(w/I),w%=I,this.$d.hours=$(w/E),w%=E,this.$d.minutes=$(w/S),w%=S,this.$d.seconds=$(w/R),w%=R,this.$d.milliseconds=w},q.toISOString=function(){var w=v(this.$d.years,"Y"),T=v(this.$d.months,"M"),R=+this.$d.days||0;this.$d.weeks&&(R+=7*this.$d.weeks);var S=v(R,"D"),E=v(this.$d.hours,"H"),I=v(this.$d.minutes,"M"),O=this.$d.seconds||0;this.$d.milliseconds&&(O+=this.$d.milliseconds/1e3,O=Math.round(1e3*O)/1e3);var A=v(O,"S"),G=w.negative||T.negative||S.negative||E.negative||I.negative||A.negative,C=E.format||I.format||A.format?"T":"",P=(G?"-":"")+"P"+w.format+T.format+S.format+C+E.format+I.format+A.format;return"P"===P||"-P"===P?"P0D":P},q.toJSON=function(){return this.toISOString()},q.format=function(w){var R=w||"YYYY-MM-DDTHH:mm:ss",S={Y:this.$d.years,YY:T.s(this.$d.years,2,"0"),YYYY:T.s(this.$d.years,4,"0"),M:this.$d.months,MM:T.s(this.$d.months,2,"0"),D:this.$d.days,DD:T.s(this.$d.days,2,"0"),H:this.$d.hours,HH:T.s(this.$d.hours,2,"0"),m:this.$d.minutes,mm:T.s(this.$d.minutes,2,"0"),s:this.$d.seconds,ss:T.s(this.$d.seconds,2,"0"),SSS:T.s(this.$d.milliseconds,3,"0")};return R.replace(O,function(w,T){return T||String(S[w])})},q.as=function(w){return this.$ms/P[m(w)]},q.get=function(w){var T=this.$ms,R=m(w);return"milliseconds"===R?T%=1e3:T="weeks"===R?$(T/P[R]):this.$d[R],T||0},q.add=function(w,T,R){var S;return S=T?w*P[m(T)]:c(w)?w.$ms:f(w,this).$ms,f(this.$ms+S*(R?-1:1),this)},q.subtract=function(w,T){return this.add(w,T,!0)},q.locale=function(w){var T=this.clone();return T.$l=w,T},q.clone=function(){return f(this.$ms,this)},q.humanize=function(T){return w().add(this.$ms,"ms").locale(this.$l).fromNow(!T)},q.valueOf=function(){return this.asMilliseconds()},q.milliseconds=function(){return this.get("milliseconds")},q.asMilliseconds=function(){return this.as("milliseconds")},q.seconds=function(){return this.get("seconds")},q.asSeconds=function(){return this.as("seconds")},q.minutes=function(){return this.get("minutes")},q.asMinutes=function(){return this.as("minutes")},q.hours=function(){return this.get("hours")},q.asHours=function(){return this.as("hours")},q.days=function(){return this.get("days")},q.asDays=function(){return this.as("days")},q.weeks=function(){return this.get("weeks")},q.asWeeks=function(){return this.as("weeks")},q.months=function(){return this.get("months")},q.asMonths=function(){return this.as("months")},q.years=function(){return this.get("years")},q.asYears=function(){return this.as("years")},l}(),p=function(w,T,R){return w.add(T.years()*R,"y").add(T.months()*R,"M").add(T.days()*R,"d").add(T.hours()*R,"h").add(T.minutes()*R,"m").add(T.seconds()*R,"s").add(T.milliseconds()*R,"ms")};return function(R,S,E){w=E,T=E().$utils(),E.duration=function(w,T){return f(w,{$l:E.locale()},T)},E.isDuration=c;var I=S.prototype.add,O=S.prototype.subtract;S.prototype.add=function(w,T){return c(w)?p(this,w,1):I.bind(this)(w,T)},S.prototype.subtract=function(w,T){return c(w)?p(this,w,-1):O.bind(this)(w,T)}}})},93132:function(w){!function(T,R){w.exports=R()}(0,function(){"use strict";var w="minute",T=/[+-]\d\d(?::?\d\d)?/g,R=/([+-]|\d\d)/g;return function(S,E,I){var O=E.prototype;I.utc=function(w){var T={date:w,utc:!0,args:arguments};return new E(T)},O.utc=function(T){var R=I(this.toDate(),{locale:this.$L,utc:!0});return T?R.add(this.utcOffset(),w):R},O.local=function(){return I(this.toDate(),{locale:this.$L,utc:!1})};var A=O.parse;O.parse=function(w){w.utc&&(this.$u=!0),this.$utils().u(w.$offset)||(this.$offset=w.$offset),A.call(this,w)};var G=O.init;O.init=function(){if(this.$u){var w=this.$d;this.$y=w.getUTCFullYear(),this.$M=w.getUTCMonth(),this.$D=w.getUTCDate(),this.$W=w.getUTCDay(),this.$H=w.getUTCHours(),this.$m=w.getUTCMinutes(),this.$s=w.getUTCSeconds(),this.$ms=w.getUTCMilliseconds()}else G.call(this)};var C=O.utcOffset;O.utcOffset=function(S,E){var I=this.$utils().u;if(I(S))return this.$u?0:I(this.$offset)?C.call(this):this.$offset;if("string"==typeof S&&null===(S=function(w){void 0===w&&(w="");var S=w.match(T);if(!S)return null;var E=(""+S[0]).match(R)||["-",0,0],I=E[0],O=60*+E[1]+ +E[2];return 0===O?0:"+"===I?O:-O}(S)))return this;var O=16>=Math.abs(S)?60*S:S,A=this;if(E)return A.$offset=O,A.$u=0===S,A;if(0!==S){var G=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(A=this.local().add(O+G,w)).$offset=O,A.$x.$localOffset=G}else A=this.utc();return A};var P=O.format;O.format=function(w){var T=w||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return P.call(this,T)},O.valueOf=function(){var w=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*w},O.isUTC=function(){return!!this.$u},O.toISOString=function(){return this.toDate().toISOString()},O.toString=function(){return this.toDate().toUTCString()};var q=O.toDate;O.toDate=function(w){return"s"===w&&this.$offset?I(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():q.call(this)};var D=O.diff;O.diff=function(w,T,R){if(w&&this.$u===w.$u)return D.call(this,w,T,R);var S=this.local(),E=I(w).local();return D.call(S,E,T,R)}}})},68591:function(w){!function(T,R){w.exports=R()}(0,function(){"use strict";var w="week",T="year";return function(R,S,E){var I=S.prototype;I.week=function(R){if(void 0===R&&(R=null),null!==R)return this.add(7*(R-this.week()),"day");var S=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var I=E(this).startOf(T).add(1,T).date(S),O=E(this).endOf(w);if(I.isBefore(O))return 1}var A=E(this).startOf(T).date(S).startOf(w).subtract(1,"millisecond"),G=this.diff(A,w,!0);return G<0?E(this).startOf("week").week():Math.ceil(G)},I.weeks=function(w){return void 0===w&&(w=null),this.week(w)}}})},35408:function(w,T,R){"use strict";function _assertThisInitialized(w){if(void 0===w)throw ReferenceError("this hasn't been initialised - super() hasn't been called");return w}R.d(T,{Z:function(){return _assertThisInitialized}})},93068:function(w){"use strict";w.exports=JSON.parse("{\"blacklist_client.lua\":\"local blacklist = ARGV[num_static_argv + 1]\\n\\nif redis.call('zscore', client_last_seen_key, blacklist) then\\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\\nend\\n\\n\\nreturn {}\\n\",\"check.lua\":\"local weight = tonumber(ARGV[num_static_argv + 1])\\n\\nlocal capacity = process_tick(now, false)['capacity']\\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\\n\\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\\n\",\"conditions_check.lua\":\"local conditions_check = function (capacity, weight)\\n  return capacity == nil or weight <= capacity\\nend\\n\",\"current_reservoir.lua\":\"return process_tick(now, false)['reservoir']\\n\",\"done.lua\":\"process_tick(now, false)\\n\\nreturn tonumber(redis.call('hget', settings_key, 'done'))\\n\",\"free.lua\":\"local index = ARGV[num_static_argv + 1]\\n\\nredis.call('zadd', job_expirations_key, 0, index)\\n\\nreturn process_tick(now, false)['running']\\n\",\"get_time.lua\":\"redis.replicate_commands()\\n\\nlocal get_time = function ()\\n  local time = redis.call('time')\\n\\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\\nend\\n\",\"group_check.lua\":\"return not (redis.call('exists', settings_key) == 1)\\n\",\"heartbeat.lua\":\"process_tick(now, true)\\n\",\"increment_reservoir.lua\":\"local incr = tonumber(ARGV[num_static_argv + 1])\\n\\nredis.call('hincrby', settings_key, 'reservoir', incr)\\n\\nlocal reservoir = process_tick(now, true)['reservoir']\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn reservoir\\n\",\"init.lua\":\"local clear = tonumber(ARGV[num_static_argv + 1])\\nlocal limiter_version = ARGV[num_static_argv + 2]\\nlocal num_local_argv = num_static_argv + 2\\n\\nif clear == 1 then\\n  redis.call('del', unpack(KEYS))\\nend\\n\\nif redis.call('exists', settings_key) == 0 then\\n  -- Create\\n  local args = {'hmset', settings_key}\\n\\n  for i = num_local_argv + 1, #ARGV do\\n    table.insert(args, ARGV[i])\\n  end\\n\\n  redis.call(unpack(args))\\n  redis.call('hmset', settings_key,\\n    'nextRequest', now,\\n    'lastReservoirRefresh', now,\\n    'lastReservoirIncrease', now,\\n    'running', 0,\\n    'done', 0,\\n    'unblockTime', 0,\\n    'capacityPriorityCounter', 0\\n  )\\n\\nelse\\n  -- Apply migrations\\n  local settings = redis.call('hmget', settings_key,\\n    'id',\\n    'version'\\n  )\\n  local id = settings[1]\\n  local current_version = settings[2]\\n\\n  if current_version ~= limiter_version then\\n    local version_digits = {}\\n    for k, v in string.gmatch(current_version, \\\"([^.]+)\\\") do\\n      table.insert(version_digits, tonumber(k))\\n    end\\n\\n    -- 2.10.0\\n    if version_digits[2] < 10 then\\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\\n      redis.call('hsetnx', settings_key, 'done', 0)\\n      redis.call('hset', settings_key, 'version', '2.10.0')\\n    end\\n\\n    -- 2.11.1\\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\\n        redis.call('hmset', settings_key,\\n          'lastReservoirRefresh', now,\\n          'version', '2.11.1'\\n        )\\n      end\\n    end\\n\\n    -- 2.14.0\\n    if version_digits[2] < 14 then\\n      local old_running_key = 'b_'..id..'_running'\\n      local old_executing_key = 'b_'..id..'_executing'\\n\\n      if redis.call('exists', old_running_key) == 1 then\\n        redis.call('rename', old_running_key, job_weights_key)\\n      end\\n      if redis.call('exists', old_executing_key) == 1 then\\n        redis.call('rename', old_executing_key, job_expirations_key)\\n      end\\n      redis.call('hset', settings_key, 'version', '2.14.0')\\n    end\\n\\n    -- 2.15.2\\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\\n      redis.call('hset', settings_key, 'version', '2.15.2')\\n    end\\n\\n    -- 2.17.0\\n    if version_digits[2] < 17 then\\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\\n      redis.call('hset', settings_key, 'version', '2.17.0')\\n    end\\n\\n    -- 2.18.0\\n    if version_digits[2] < 18 then\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\\n      redis.call('hset', settings_key, 'version', '2.18.0')\\n    end\\n\\n  end\\n\\n  process_tick(now, false)\\nend\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn {}\\n\",\"process_tick.lua\":\"local process_tick = function (now, always_publish)\\n\\n  local compute_capacity = function (maxConcurrent, running, reservoir)\\n    if maxConcurrent ~= nil and reservoir ~= nil then\\n      return math.min((maxConcurrent - running), reservoir)\\n    elseif maxConcurrent ~= nil then\\n      return maxConcurrent - running\\n    elseif reservoir ~= nil then\\n      return reservoir\\n    else\\n      return nil\\n    end\\n  end\\n\\n  local settings = redis.call('hmget', settings_key,\\n    'id',\\n    'maxConcurrent',\\n    'running',\\n    'reservoir',\\n    'reservoirRefreshInterval',\\n    'reservoirRefreshAmount',\\n    'lastReservoirRefresh',\\n    'reservoirIncreaseInterval',\\n    'reservoirIncreaseAmount',\\n    'reservoirIncreaseMaximum',\\n    'lastReservoirIncrease',\\n    'capacityPriorityCounter',\\n    'clientTimeout'\\n  )\\n  local id = settings[1]\\n  local maxConcurrent = tonumber(settings[2])\\n  local running = tonumber(settings[3])\\n  local reservoir = tonumber(settings[4])\\n  local reservoirRefreshInterval = tonumber(settings[5])\\n  local reservoirRefreshAmount = tonumber(settings[6])\\n  local lastReservoirRefresh = tonumber(settings[7])\\n  local reservoirIncreaseInterval = tonumber(settings[8])\\n  local reservoirIncreaseAmount = tonumber(settings[9])\\n  local reservoirIncreaseMaximum = tonumber(settings[10])\\n  local lastReservoirIncrease = tonumber(settings[11])\\n  local capacityPriorityCounter = tonumber(settings[12])\\n  local clientTimeout = tonumber(settings[13])\\n\\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\\n\\n  --\\n  -- Process 'running' changes\\n  --\\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\\n\\n  if #expired > 0 then\\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\\n\\n    local flush_batch = function (batch, acc)\\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\\n                      redis.call('hdel',  job_weights_key, unpack(batch))\\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\\n                      redis.call('hdel',  job_clients_key, unpack(batch))\\n\\n      -- Calculate sum of removed weights\\n      for i = 1, #weights do\\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\\n      end\\n\\n      -- Calculate sum of removed weights by client\\n      local client_weights = {}\\n      for i = 1, #clients do\\n        local removed = tonumber(weights[i]) or 0\\n        if removed > 0 then\\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\\n        end\\n      end\\n    end\\n\\n    local acc = {\\n      ['total'] = 0,\\n      ['client_weights'] = {}\\n    }\\n    local batch_size = 1000\\n\\n    -- Compute changes to Zsets and apply changes to Hashes\\n    for i = 1, #expired, batch_size do\\n      local batch = {}\\n      for j = i, math.min(i + batch_size - 1, #expired) do\\n        table.insert(batch, expired[j])\\n      end\\n\\n      flush_batch(batch, acc)\\n    end\\n\\n    -- Apply changes to Zsets\\n    if acc['total'] > 0 then\\n      redis.call('hincrby', settings_key, 'done', acc['total'])\\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\\n    end\\n\\n    for client, weight in pairs(acc['client_weights']) do\\n      redis.call('zincrby', client_running_key, -weight, client)\\n    end\\n  end\\n\\n  --\\n  -- Process 'reservoir' changes\\n  --\\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\\n    reservoir = reservoirRefreshAmount\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'lastReservoirRefresh', now\\n    )\\n  end\\n\\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\\n    local incr = reservoirIncreaseAmount * num_intervals\\n    if reservoirIncreaseMaximum ~= nil then\\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\\n    end\\n    if incr > 0 then\\n      reservoir = (reservoir or 0) + incr\\n    end\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\\n    )\\n  end\\n\\n  --\\n  -- Clear unresponsive clients\\n  --\\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\\n  local unresponsive_lookup = {}\\n  local terminated_clients = {}\\n  for i = 1, #unresponsive do\\n    unresponsive_lookup[unresponsive[i]] = true\\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\\n      table.insert(terminated_clients, unresponsive[i])\\n    end\\n  end\\n  if #terminated_clients > 0 then\\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\\n  end\\n\\n  --\\n  -- Broadcast capacity changes\\n  --\\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\\n\\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\\n    -- always_publish or was not unlimited, now unlimited\\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\\n\\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\\n    -- capacity was increased\\n    -- send the capacity message to the limiter having the lowest number of running jobs\\n    -- the tiebreaker is the limiter having not registered a job in the longest time\\n\\n    local lowest_concurrency_value = nil\\n    local lowest_concurrency_clients = {}\\n    local lowest_concurrency_last_registered = {}\\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\\n\\n    for i = 1, #client_concurrencies, 2 do\\n      local client = client_concurrencies[i]\\n      local concurrency = tonumber(client_concurrencies[i+1])\\n\\n      if (\\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\\n      ) and (\\n        not unresponsive_lookup[client]\\n      ) and (\\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\\n      ) then\\n        lowest_concurrency_value = concurrency\\n        table.insert(lowest_concurrency_clients, client)\\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\\n        table.insert(lowest_concurrency_last_registered, last_registered)\\n      end\\n    end\\n\\n    if #lowest_concurrency_clients > 0 then\\n      local position = 1\\n      local earliest = lowest_concurrency_last_registered[1]\\n\\n      for i,v in ipairs(lowest_concurrency_last_registered) do\\n        if v < earliest then\\n          position = i\\n          earliest = v\\n        end\\n      end\\n\\n      local next_client = lowest_concurrency_clients[position]\\n      redis.call('publish', 'b_'..id,\\n        'capacity-priority:'..(final_capacity or '')..\\n        ':'..next_client..\\n        ':'..capacityPriorityCounter\\n      )\\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\\n    else\\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\\n    end\\n  end\\n\\n  return {\\n    ['capacity'] = final_capacity,\\n    ['running'] = running,\\n    ['reservoir'] = reservoir\\n  }\\nend\\n\",\"queued.lua\":\"local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\\n\\nlocal sum = 0\\nfor i = 1, #client_queued do\\n  sum = sum + tonumber(client_queued[i])\\nend\\n\\nreturn sum\\n\",\"refresh_expiration.lua\":\"local refresh_expiration = function (now, nextRequest, groupTimeout)\\n\\n  if groupTimeout ~= nil then\\n    local ttl = (nextRequest + groupTimeout) - now\\n\\n    for i = 1, #KEYS do\\n      redis.call('pexpire', KEYS[i], ttl)\\n    end\\n  end\\n\\nend\\n\",\"refs.lua\":\"local settings_key = KEYS[1]\\nlocal job_weights_key = KEYS[2]\\nlocal job_expirations_key = KEYS[3]\\nlocal job_clients_key = KEYS[4]\\nlocal client_running_key = KEYS[5]\\nlocal client_num_queued_key = KEYS[6]\\nlocal client_last_registered_key = KEYS[7]\\nlocal client_last_seen_key = KEYS[8]\\n\\nlocal now = tonumber(ARGV[1])\\nlocal client = ARGV[2]\\n\\nlocal num_static_argv = 2\\n\",\"register.lua\":\"local index = ARGV[num_static_argv + 1]\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\\n\\nlocal state = process_tick(now, false)\\nlocal capacity = state['capacity']\\nlocal reservoir = state['reservoir']\\n\\nlocal settings = redis.call('hmget', settings_key,\\n  'nextRequest',\\n  'minTime',\\n  'groupTimeout'\\n)\\nlocal nextRequest = tonumber(settings[1])\\nlocal minTime = tonumber(settings[2])\\nlocal groupTimeout = tonumber(settings[3])\\n\\nif conditions_check(capacity, weight) then\\n\\n  redis.call('hincrby', settings_key, 'running', weight)\\n  redis.call('hset', job_weights_key, index, weight)\\n  if expiration ~= nil then\\n    redis.call('zadd', job_expirations_key, now + expiration, index)\\n  end\\n  redis.call('hset', job_clients_key, index, client)\\n  redis.call('zincrby', client_running_key, weight, client)\\n  redis.call('hincrby', client_num_queued_key, client, -1)\\n  redis.call('zadd', client_last_registered_key, now, client)\\n\\n  local wait = math.max(nextRequest - now, 0)\\n  local newNextRequest = now + wait + minTime\\n\\n  if reservoir == nil then\\n    redis.call('hset', settings_key,\\n      'nextRequest', newNextRequest\\n    )\\n  else\\n    reservoir = reservoir - weight\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'nextRequest', newNextRequest\\n    )\\n  end\\n\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\n\\n  return {true, wait, reservoir}\\n\\nelse\\n  return {false}\\nend\\n\",\"register_client.lua\":\"local queued = tonumber(ARGV[num_static_argv + 1])\\n\\n-- Could have been re-registered concurrently\\nif not redis.call('zscore', client_last_seen_key, client) then\\n  redis.call('zadd', client_running_key, 0, client)\\n  redis.call('hset', client_num_queued_key, client, queued)\\n  redis.call('zadd', client_last_registered_key, 0, client)\\nend\\n\\nredis.call('zadd', client_last_seen_key, now, client)\\n\\nreturn {}\\n\",\"running.lua\":\"return process_tick(now, false)['running']\\n\",\"submit.lua\":\"local queueLength = tonumber(ARGV[num_static_argv + 1])\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\n\\nlocal capacity = process_tick(now, false)['capacity']\\n\\nlocal settings = redis.call('hmget', settings_key,\\n  'id',\\n  'maxConcurrent',\\n  'highWater',\\n  'nextRequest',\\n  'strategy',\\n  'unblockTime',\\n  'penalty',\\n  'minTime',\\n  'groupTimeout'\\n)\\nlocal id = settings[1]\\nlocal maxConcurrent = tonumber(settings[2])\\nlocal highWater = tonumber(settings[3])\\nlocal nextRequest = tonumber(settings[4])\\nlocal strategy = tonumber(settings[5])\\nlocal unblockTime = tonumber(settings[6])\\nlocal penalty = tonumber(settings[7])\\nlocal minTime = tonumber(settings[8])\\nlocal groupTimeout = tonumber(settings[9])\\n\\nif maxConcurrent ~= nil and weight > maxConcurrent then\\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\\nend\\n\\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\\n  and not (\\n    conditions_check(capacity, weight)\\n    and nextRequest - now <= 0\\n  )\\n)\\n\\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\\n\\nif blocked then\\n  local computedPenalty = penalty\\n  if computedPenalty == nil then\\n    if minTime == 0 then\\n      computedPenalty = 5000\\n    else\\n      computedPenalty = 15 * minTime\\n    end\\n  end\\n\\n  local newNextRequest = now + computedPenalty + minTime\\n\\n  redis.call('hmset', settings_key,\\n    'unblockTime', now + computedPenalty,\\n    'nextRequest', newNextRequest\\n  )\\n\\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\\n  local queued_reset = {}\\n  for i = 1, #clients_queued_reset do\\n    table.insert(queued_reset, clients_queued_reset[i])\\n    table.insert(queued_reset, 0)\\n  end\\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\\n\\n  redis.call('publish', 'b_'..id, 'blocked:')\\n\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\nend\\n\\nif not blocked and not reachedHWM then\\n  redis.call('hincrby', client_num_queued_key, client, 1)\\nend\\n\\nreturn {reachedHWM, blocked, strategy}\\n\",\"update_settings.lua\":\"local args = {'hmset', settings_key}\\n\\nfor i = num_static_argv + 1, #ARGV do\\n  table.insert(args, ARGV[i])\\nend\\n\\nredis.call(unpack(args))\\n\\nprocess_tick(now, true)\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn {}\\n\",\"validate_client.lua\":\"if not redis.call('zscore', client_last_seen_key, client) then\\n  return redis.error_reply('UNKNOWN_CLIENT')\\nend\\n\\nredis.call('zadd', client_last_seen_key, now, client)\\n\",\"validate_keys.lua\":\"if not (redis.call('exists', settings_key) == 1) then\\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\\nend\\n\"}")},31447:function(w){"use strict";w.exports={i:"2.19.5"}}}]);
//# sourceMappingURL=3709-98c783dfb6b6604d.js.map